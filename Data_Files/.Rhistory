alleles_samp <- colSums(sp_genind@tab[sample(1:nrow(sp_genind@tab), t),],na.rm=T)
#Then simply compare that sample to your wild population with allele_cat
garden_sum_results_tree[t,nrep] <- sum(alleles_samp[allele_cat[[1]]]>0, na.rm=T)
#Divide by the number of alleles
garden_sum_results_df[t,nrep] <- t(t(garden_sum_results_tree[,nrep])/garden_sum_results_tree[length(garden_sum_results_tree[,1]),nrep])
}
}
#Repeat the resampling many times
for (nrep in 1:num_reps) {
#create empty matrix to store sampling code
alleles_samp <- matrix(nrow=nrow(sp_genind@tab)-1,ncol=1)
#This loop will sample trees from t = 2 to the total number of trees
for (t in 2:(nrow(sp_genind@tab)-1)){
#create a sample of trees of length t, by using 'sample()' which randomly samples rows
alleles_samp <- colSums(sp_genind@tab[sample(1:nrow(sp_genind@tab), t),],na.rm=T)
#Then simply compare that sample to your wild population with allele_cat
garden_sum_results_tree[t,nrep] <- sum(alleles_samp[allele_cat[[1]]]>0, na.rm=T)
#Divide by the number of alleles
#garden_sum_results_df[t,nrep] <- t(t(garden_sum_results_tree[,nrep])/garden_sum_results_tree[length(garden_sum_results_tree[,1]),nrep])
}
}
garden_sum_results_tree
nrow(sp_genind@tab)-1
#create summary results for allelic capture
garden_sum_results_tree <- matrix(nrow = nrow(sp_genind@tab)-1, ncol = num_reps)
sum(alleles_samp[allele_cat[[1]]]>0, na.rm=T)
alleles_samp
#create a sample of trees of length t, by using 'sample()' which randomly samples rows
alleles_samp <- colSums(sp_genind@tab[sample(1:nrow(sp_genind@tab), 2),],na.rm=T)
alleles_samp
#Then simply compare that sample to your wild population with allele_cat
garden_sum_results_tree[2,nrep] <- sum(alleles_samp[allele_cat[[1]]]>0, na.rm=T)
garden_sum_results_tree
#create a sample of trees of length t, by using 'sample()' which randomly samples rows
alleles_samp <- colSums(sp_genind@tab[sample(1:nrow(sp_genind@tab), 2),],na.rm=T)
#Then simply compare that sample to your wild population with allele_cat
garden_sum_results_tree[2,1] <- sum(alleles_samp[allele_cat[[1]]]>0, na.rm=T)
garden_sum_results_tree
garden_sum_results_tree[2,1]
sum(alleles_samp[allele_cat[[1]]]>0, na.rm=T)
head(garden_sum_results_tree)
garden_sum_results_tree[2,1]
head(alleles_samp)
#Repeat the resampling many times
for (nrep in 1:num_reps) {
#create empty matrix to store sampling code
alleles_samp <- matrix(nrow=nrow(sp_genind@tab)-1,ncol=nrep)
#This loop will sample trees from t = 2 to the total number of trees
for (t in 2:(nrow(sp_genind@tab)-1)){
#create a sample of trees of length t, by using 'sample()' which randomly samples rows
alleles_samp <- colSums(sp_genind@tab[sample(1:nrow(sp_genind@tab), 2),],na.rm=T)
#Then simply compare that sample to your wild population with allele_cat
garden_sum_results_tree[2,1] <- sum(alleles_samp[allele_cat[[1]]]>0, na.rm=T)
#Divide by the number of alleles
#garden_sum_results_df[t,nrep] <- t(t(garden_sum_results_tree[,nrep])/garden_sum_results_tree[length(garden_sum_results_tree[,1]),nrep])
}
}
#Repeat the resampling many times
for (nrep in 1:num_reps) {
#create empty matrix to store sampling code
alleles_samp <- matrix(nrow=nrow(sp_genind@tab)-1,ncol=nrep)
#This loop will sample trees from t = 2 to the total number of trees
for (t in 2:(nrow(sp_genind@tab)-1)){
#create a sample of trees of length t, by using 'sample()' which randomly samples rows
alleles_samp <- colSums(sp_genind@tab[sample(1:nrow(sp_genind@tab), t),],na.rm=T)
#Then simply compare that sample to your wild population with allele_cat
garden_sum_results_tree[t,nrep] <- sum(alleles_samp[allele_cat[[1]]]>0, na.rm=T)
#Divide by the number of alleles
#garden_sum_results_df[t,nrep] <- t(t(garden_sum_results_tree[,nrep])/garden_sum_results_tree[length(garden_sum_results_tree[,1]),nrep])
}
}
garden_sum_results_tree
QUAC_genind <- read.genepop("Adegenet_Files/Garden_Wild/QUAC_woK_garden_wild_clean.gen", ncode = 3)
QUAC_df <- read.csv("Data_Frames/QUAC_woK_allpop_df.csv")
levels(QUAC_genind@pop) <- unique(QUAC_df$Garden_Wild)
View(QUAC_df)
num_reps <- 1000
sp_genind <- seppop(QUAC_genind)[[1]]
sp_genind
n_total_indivs <- length(sp_genind@tab[,1])
n_ind_p_pop <- table(sp_genind@pop)
#list out allele categories
list_allele_cat<-c("global","glob_v_com","glob_com","glob_lowfr","glob_rare","reg_rare","loc_com_d1","loc_com_d2","loc_rare")
#calculate allele category
allele_cat <- get.allele.cat(sp_genind, region_makeup=NULL, 2, n_ind_p_pop,n_drop = 0, glob_only=T)
#load in function to calculate allele frequency categories
source("../Analyses/RScripts/Fa_sample_funcs.R")
#calculate allele category
allele_cat <- get.allele.cat(sp_genind, region_makeup=NULL, 2, n_ind_p_pop,n_drop = 0, glob_only=T)
#create summary results for allelic capture
sum_results_tree <- array(dim = c((nrow(sp_genind@tab)-1), length(list_sp_allele_cat), num_reps))
#create a summary table
sum_results_df <- array(dim = c((nrow(sp_genind@tab)-1), length(list_sp_allele_cat), num_reps))
n_total_indivs <- length(sp_genind@tab[,1])
n_ind_p_pop <- table(sp_genind@pop)
#list out allele categories
list_allele_cat<-c("global","glob_v_com","glob_com","glob_lowfr","glob_rare","reg_rare","loc_com_d1","loc_com_d2","loc_rare")
#calculate allele category
allele_cat <- get.allele.cat(sp_genind, region_makeup=NULL, 2, n_ind_p_pop,n_drop = 0, glob_only=T)
#create summary results for allelic capture
sum_results_tree <- array(dim = c((nrow(sp_genind@tab)-1), length(list_sp_allele_cat), num_reps))
#create summary results for allelic capture
sum_results_tree <- array(dim = c((nrow(sp_genind@tab)-1), length(list_allele_cat), num_reps))
#create a summary table
sum_results_df <- array(dim = c((nrow(sp_genind@tab)-1), length(list_allele_cat), num_reps))
#create summary results for allelic capture
sum_results_tree <- array(dim = c((nrow(sp_genind@tab)-1), length(list_allele_cat), num_reps))
#create a summary table
sum_results_df <- array(dim = c((nrow(sp_genind@tab)-1), length(list_allele_cat), num_reps))
#create summary results for allelic capture
sum_results_tree <- array(dim = c((nrow(sp_genind@tab)-1), length(list_allele_cat), num_reps))
#create a summary table
sum_results_df <- array(dim = c((nrow(sp_genind@tab)-1), length(list_allele_cat), num_reps))
#Repeat the resampling many times
for (nrep in 1:num_reps) {
#create empty matrix to store sampling code
alleles_samp <- matrix(nrow=nrow(sp_genind@tab)-1,ncol=length(list_allele_cat))
#This loop will sample trees from t = 2 to the total number of trees
for (t in 2:(nrow(sp_genind@tab)-1)){
#create a sample of trees of length t, by using 'sample()' which randomly samples rows
alleles_samp <- colSums(sp_genind@tab[sample(1:nrow(sp_genind@tab), t),],na.rm=T)
#Then simply compare that sample to your wild population with allele_cat
for (cat in 1:length(allele_cat)) sum_results_tree[t,cat,nrep] <- sum(alleles_samp[allele_cat[[cat]]]>0, na.rm=T)
#Divide by the number of alleles
sum_results_df[,,nrep] <- t(t(sum_results_tree[,,nrep])/sum_results_tree[length(sum_results_tree[,1,1]),,nrep])
}
}
#create a summary table
garden_results_df <- array(dim = c((nrow(sp_genind@tab)-1), length(list_allele_cat), num_reps))
#Repeat the resampling many times
for (nrep in 1:num_reps) {
#create empty matrix to store sampling code
alleles_samp <- matrix(nrow=nrow(sp_genind@tab)-1,ncol=length(list_allele_cat))
#This loop will sample trees from t = 2 to the total number of trees
for (t in 2:(nrow(sp_genind@tab)-1)){
#create a sample of trees of length t, by using 'sample()' which randomly samples rows
alleles_samp <- colSums(sp_genind@tab[sample(1:nrow(sp_genind@tab), t),],na.rm=T)
#Then simply compare that sample to your wild population with allele_cat
for (cat in 1:length(allele_cat)) sum_results_tree[t,cat,nrep] <- sum(alleles_samp[allele_cat[[cat]]]>0, na.rm=T)
#Divide by the number of alleles
sum_results_df[,,nrep] <- t(t(sum_results_tree[,,nrep])/sum_results_tree[length(sum_results_tree[,1,1]),,nrep])
}
}
#create summary results for allelic capture
garden_results_tree <- array(dim = c((nrow(sp_genind@tab)-1), length(list_allele_cat), num_reps))
#create a summary table
garden_results_df <- array(dim = c((nrow(sp_genind@tab)-1), length(list_allele_cat), num_reps))
#Repeat the resampling many times
for (nrep in 1:num_reps) {
#create empty matrix to store sampling code
alleles_samp <- matrix(nrow=nrow(sp_genind@tab)-1,ncol=length(list_allele_cat))
#This loop will sample trees from t = 2 to the total number of trees
for (t in 2:(nrow(sp_genind@tab)-1)){
#create a sample of trees of length t, by using 'sample()' which randomly samples rows
alleles_samp <- colSums(sp_genind@tab[sample(1:nrow(sp_genind@tab), t),],na.rm=T)
#Then simply compare that sample to your wild population with allele_cat
for (cat in 1:length(allele_cat)) garden_results_tree[t,cat,nrep] <- sum(alleles_samp[allele_cat[[cat]]]>0, na.rm=T)
#Divide by the number of alleles
garden_results_df[,,nrep] <- t(t(garden_results_tree[,,nrep])/garden_results_tree[length(garden_results_tree[,1,1]),,nrep])
}
}
head(garden_results_df[,,1])
#run on wild individuals
sp_genind <- seppop(QUAC_genind)[[2]]
n_total_indivs <- length(sp_genind@tab[,1])
n_ind_p_pop <- table(sp_genind@pop)
#list out allele categories
list_allele_cat<-c("global","glob_v_com","glob_com","glob_lowfr","glob_rare","reg_rare","loc_com_d1","loc_com_d2","loc_rare")
#calculate allele category
allele_cat <- get.allele.cat(sp_genind, region_makeup=NULL, 2, n_ind_p_pop,n_drop = 0, glob_only=T)
#create summary results for allelic capture
wild_results_tree <- array(dim = c((nrow(sp_genind@tab)-1), length(list_allele_cat), num_reps))
#create a summary table
wild_results_df <- array(dim = c((nrow(sp_genind@tab)-1), length(list_allele_cat), num_reps))
#Repeat the resampling many times
for (nrep in 1:num_reps) {
#create empty matrix to store sampling code
alleles_samp <- matrix(nrow=nrow(sp_genind@tab)-1,ncol=length(list_allele_cat))
#This loop will sample trees from t = 2 to the total number of trees
for (t in 2:(nrow(sp_genind@tab)-1)){
#create a sample of trees of length t, by using 'sample()' which randomly samples rows
alleles_samp <- colSums(sp_genind@tab[sample(1:nrow(sp_genind@tab), t),],na.rm=T)
#Then simply compare that sample to your wild population with allele_cat
for (cat in 1:length(allele_cat)) wild_results_tree[t,cat,nrep] <- sum(alleles_samp[allele_cat[[cat]]]>0, na.rm=T)
#Divide by the number of alleles
wild_results_df[,,nrep] <- t(t(wild_results_tree[,,nrep])/wild_results_tree[length(wild_results_tree[,1,1]),,nrep])
}
}
#mean across reps using apply
garden_all_mean <- apply(garden_results_df[,,1:num_reps],c(1,2),mean,na.rm=T)*100
garden_all_mean
#mean across all wild individuals
wild_all_mean <- apply(wild_results_df[,,1:num_reps],c(1,2),mean,na.rm=T)*100
plot(wild_all_mean[,1])
plot(wild_all_mean[,1], garden_all_mean[,1])
plot(garden_all_mean[,1])
plot(garden_all_mean[,1], wild_all_mean[,1], xlim = c(0,300))
##plot both lines
plot(garden_all_mean[,1], col = "green")
##plot both lines
plot(garden_all_mean[,1], col = "darkgreen", pch = 17)
##plot both lines
plot(garden_all_mean[,1], col = "seagreen1", pch = 17)
plot(wild_all_mean[,2], col = "darkgreen", pch 17, add = TRUE)
points(wild_all_mean[,2], col = "darkgreen", pch 17)
points(wild_all_mean[,2], col = "darkgreen", pch = 17)
##plot both lines
plot(garden_all_mean[,1], col = "seagreen1", pch = 17, xlim = c(0,300), xlab = "Number of individuals",
ylab = "Percent Allele Capture", ylim = c(0,100))
##plot both lines
plot(garden_all_mean[,1], col = "seagreen1", pch = 15, xlim = c(0,300), xlab = "Number of individuals",
ylab = "Percent Allele Capture", ylim = c(0,100))
points(wild_all_mean[,2], col = "darkgreen", pch = 17)
legend('bottomright', legend = c("Garden", "Wild"), pch = 15, col = c("seagreen1", "darkgreen"))
##plot both lines
plot(garden_all_mean[,1], col = "seagreen1", pch = 15, xlim = c(0,300), xlab = "Number of individuals",
ylab = "Percent Allele Capture", ylim = c(0,100))
points(wild_all_mean[,2], col = "darkgreen", pch = 15)
legend('bottomright', legend = c("Garden", "Wild"), pch = 15, col = c("seagreen1", "darkgreen"))
legend('bottomright', legend = c("Garden", "Wild"), pch = 15, col = c("seagreen1", "darkgreen"), bty = 'n', border = "black")
##plot both lines
plot(garden_all_mean[,1], col = "seagreen1", pch = 15, xlim = c(0,300), xlab = "Number of individuals",
ylab = "Percent Allele Capture", ylim = c(0,100))
points(wild_all_mean[,2], col = "darkgreen", pch = 15)
legend('bottomright', legend = c("Garden", "Wild"), pch = 15, col = c("seagreen1", "darkgreen"), bty = 'n')
##plot both lines
pdf("G:/Shared drives/Emily_Schumacher/Project_Folders/GCC_QUAC_ZAIN/Analyses/Results/Garden_Wild_Comparison/QUAC_allresampling_garden_wild.pdf", width = 10, height = 8)
plot(garden_all_mean[,1], col = "seagreen1", pch = 15, xlim = c(0,300), xlab = "Number of individuals",
ylab = "Percent Allele Capture", ylim = c(0,100))
points(wild_all_mean[,2], col = "darkgreen", pch = 15)
legend('bottomright', legend = c("Garden", "Wild"), pch = 15, col = c("seagreen1", "darkgreen"), bty = 'n')
dev.off()
wild_all_mean[,1]
which(wild_all_mean[,1] >= 95)[1]
#line to store in a data frame
wild_min_95 <- which(wild_all_mean[,1] >= 95)[1]
#
garden_min_95 <- which(garden_all_mean[,1] >= 95)[1]
garden_min_95
##maternal accession code
#load in data frame with maternal accession information
sp_accessions <- read.csv("Data_Frames/QUAC_garden_maternal_accessions.csv")
##maternal accession code
#load in data frame with maternal accession information
QUAC_accessions <- read.csv("Data_Frames/QUAC_garden_maternal_accessions.csv")
source("../Analyses/RScript/maternal_accession.R")
#########################################
#           Relatedness Df Code         #
#########################################
mat_accession <- function(x){
#add a column with cleaned accession names
sp_garden_accessions <- x %>% mutate(accession_simple = gsub("\\*.*","",x$Accession))
#create a list of all the botanic gardens for each species
sp_bg_names <- unique(x[,2])
#create data frame to store results
sp_bg_maternal <- matrix(nrow = length(sp_bg_names), ncol = 1)
#code calculate maternal lines by garden
for(garden in 1:length(sp_bg_names)){
#count unique maternal lines for each botanic garden
sp_bg_maternal[garden,1] <- length(unique(sp_garden_accessions[sp_garden_accessions[,2] == paste0(sp_bg_names[[garden]]),]$accession_simple))
}
rownames(sp_bg_maternal) <- sp_bg_names
colnames(sp_bg_maternal) <- "mat_acc"
return(sp_bg_maternal)
}
#run maternal accession code
mat_df <- accession_count(sp_temp_accession_df)
#########################################
#           Relatedness Df Code         #
#########################################
mat_accession <- function(x){
#add a column with cleaned accession names
sp_garden_accessions <- x %>% mutate(accession_simple = gsub("\\*.*","",x$Accession))
#create a list of all the botanic gardens for each species
sp_bg_names <- unique(x[,2])
#create data frame to store results
sp_bg_maternal <- matrix(nrow = length(sp_bg_names), ncol = 1)
#code calculate maternal lines by garden
for(garden in 1:length(sp_bg_names)){
#count unique maternal lines for each botanic garden
sp_bg_maternal[garden,1] <- length(unique(sp_garden_accessions[sp_garden_accessions[,2] == paste0(sp_bg_names[[garden]]),]$accession_simple))
}
rownames(sp_bg_maternal) <- sp_bg_names
colnames(sp_bg_maternal) <- "mat_acc"
return(sp_bg_maternal)
}
#run maternal accession code
mat_df <- mat_accession(sp_temp_accession_df)
library(dplyr)
#run maternal accession code
mat_df <- mat_accession(sp_temp_accession_df)
#run maternal accession code
mat_df <- mat_accession(QUAC_accessions)
mat_df
#run maternal accession code
#add a column with cleaned accession names
sp_garden_accessions <- QUAC_accessions %>% mutate(accession_simple = gsub("\\*.*","",x$Accession))
#run maternal accession code
#add a column with cleaned accession names
sp_garden_accessions <- QUAC_accessions %>% mutate(accession_simple = gsub("\\*.*","",QUAC_accessions$Accession))
View(sp_garden_accessions)
View(sp_garden_accessions)
View(QUAC_df)
#first need to run the relatedness analysis
relatedness_df <- Demerelate(QUAC_df[,-2], object = T, value = "loiselle", NA.rm	= TRUE)
library(Demerelate)
#first need to run the relatedness analysis
relatedness_df <- Demerelate(QUAC_df[,-2], object = T, value = "loiselle", NA.rm	= TRUE)
#next, determine the names of halfsibs
halfsibs_names <- names(which(unlist(relatedness_df$Empirical_Relatedness$Garden) > 0.125))
#now clean the front
halfsibs_clean_front <- gsub("^.*\\.","", halfsibs_names)
#clean the back for the list of halfsibs
halfsibs_clean_back <- gsub("^.*\\_","", halfsibs_clean_front)
#create list of half-sibs
halfsib_list <- unique(halfsibs_clean_back)
halfsib_list
length(halfsib_list)
View(QUAC_df)
455 - 279
install.packages("starmie")
#' Run the CLUMPP algorithms.
#' @param Q_list A list of of Q matrices.
#' @param method The method the algorithm uses to infer the correct permutations. One of 'greedy' or 'greedyLargeK' or 'stephens' or 'none'
#' @importFrom proxy simil
#' @export
#' @examples
#' # Read in Structure files
#' multiple_runs_k10 <- exampleStructure("mcmc_diagnostics")
#' Q_list <- lapply(multiple_runs_k10, getQ)
#' clumpak_results <- clumpak(Q_list)
clumpak <- function(Q_list, method="none"){
# i/o checks
if (!(method %in% c("greedy", "greedyLargeK", "stephens", "none"))) {
stop("Not a valid CLUMPP method, please use one of: 'greedy', 'greedyLargeK', 'stephens' or 'none'")
}
if(!all(unlist(lapply(Q_list, inherits, "matrix"))))
stop("cluster runs must be a list of Q matrices")
if (method!="none"){
Q_list <- clumpp(Q_list, method)$Q_list
}
# check MCL installed
if (requireNamespace("MCL", quietly = TRUE)) {
simMatrix <- as.matrix(simil(Q_list, method=G))
diag(simMatrix) <- 1
t <- calcThreshold(simMatrix)
simMatrix[simMatrix<t] <- 0
clusters <- MCL::mcl(simMatrix, addLoops = TRUE)$Cluster
split(Q_list, clusters)
} else {
message("MCL package required for CLUMPAK, please install it.")
message(paste("Returning Q_list...with method", method))
Q_list
}
}
calcThreshold <- function(simMatrix){
#We want to choose a threshold t such that the number of singletons
# is less than 10% of nodes and the mean node degree is at least 50%
# of the total number of nodes.
thresholds <- as.vector(simMatrix)
thresholds <- thresholds[order(thresholds)]
is_valid <- unlist(lapply(thresholds, function(t){
degrees <- apply(simMatrix, 1, function(r) sum(r[r>t]))
((sum(degrees==1)/length(degrees))<0.1) & (mean(degrees) >= 0.5*nrow(simMatrix))
}))
threshold <- thresholds[is_valid][sum(is_valid)]
return(threshold)
}
G <- function(Q_1, Q_2){
W <- matrix(1, nrow(Q_1), ncol(Q_1))/ncol(Q_1)
1-norm(Q_1-Q_2, type="F")/sqrt(norm(Q_1-W, type="F")*norm(Q_2-W, type="F"))
}
#' # find 'best' K according to results
#' deltaK <- evanno_results$variable == 'delta K'
#' max_deltaK <- which(evanno_results$value == max(evanno_results$value[deltaK], na.rm = TRUE))
#' evanno_results[max_deltaK, ]
#' lK <- structure_results$variable == 'L(K)'
#' max_Lk <- which(structure_results$value == max(structure_results$value[lK], na.rm = TRUE))
#' structure_results[max_Lk,]
#' # admixture example
#' multi_K_admix <- exampleAdmixture()
#' bestK(multi_K_admix)
bestK <- function(x, method, plot = TRUE) {
UseMethod("bestK", x)
}
#' @method bestK structList
#' @export
bestK.structList <- function(x, method = "evanno", plot = TRUE) {
if (!(method %in% c("evanno", "structure")))
stop("method must be one of 'evanno' or 'structure'")
if ( !is.logical(plot) | is.na(plot) )
stop("plot must be one of TRUE or FALSE")
message("Creating diagnostic plots for structure runs.")
params_sizes <- lapply(x, getD)
posterior_probs <- data.frame(K=unlist(lapply(x, getK)),
pos_prob=unlist(lapply(x, getPosterior)),
d = unlist(lapply(params_sizes, function(i) i$d)),
n = unlist(lapply(params_sizes, function(i) i$n)))
# fit stats
ll_summary <- matrix(unlist(lapply(x, getFitStats)), ncol = 2, byrow = TRUE)
# compute average AIC/BIC over runs + standard errors
posterior_probs$aic <- -2*posterior_probs$pos_prob + 2*posterior_probs$d
posterior_probs$bic <- -2*posterior_probs$pos_prob + posterior_probs$d * log(posterior_probs$n)
# Gelman 2013 method for computing DIC
posterior_probs$dic <- -2*ll_summary[,1] + 2*ll_summary[,2]
# If K are not sequential or do not have equal number of runs just
# perform the structure approach and produce a simpler plot
Ks <- table(posterior_probs$K)
# check for whether it is valid to compute Evanno method
evanno_invalid <- !is.sequential(names(Ks)) | !all(Ks[[1]]==Ks) | all(Ks == 1)
if (evanno_invalid | method == "structure") {
if (method!="structure") {
if (all(Ks == 1)) {
stop("Not enough information to compute Evanno statistics.")
}
warning("WARNING! K values are not sequential or there are
an uneven number of runs per K.
Reverting to structure method instead.")
}
model_ll <- bestK_structure(posterior_probs, plot)
model_ll
} else {
model_ll <- bestK_evanno(posterior_probs, plot)
model_ll
}
}
#' @method bestK admixList
#' @export
bestK.admixList <- function(x, method = NULL, plot = TRUE) {
message("Creating diagnositc plots for admixture runs")
log_df <- combineLogs(x)
if ( is.null(log_df) ) {
stop("Need log file information to produce diagnositc plots")
}
log_df_tidy <- data.table::melt(combineLogs(x),
id.vars = "K",
variable.name = "statistic")
if (plot) {
gg <- ggplot(log_df_tidy, aes_(x = ~K, y = ~value)) +
geom_point() +
facet_wrap(~ statistic, ncol = 2, scales = "free_y") +
theme_bw()
suppressWarnings(print(gg))
}
return(log_df)
}
#' @importFrom stats sd
bestK_evanno <- function(posterior_probs, plot) {
# plot delta K
# split by K and calculate the first and second derivatives
split_posterior_probs <- split(posterior_probs, posterior_probs$K)
split_posterior_probs <- split_posterior_probs[order(as.numeric(names(split_posterior_probs)))]
# empty data frame for storing results
output_variables <- c("L(K)", "L'(K)",  "L''(K)", "delta K")
output_values <- list()
k_all <- min(posterior_probs$K):max(posterior_probs$K)
for (k in k_all) {
LK <-  split_posterior_probs[[k]]$pos_prob
if(k > min(k_all) & k < max(k_all)) {
dK <- split_posterior_probs[[k]]$pos_prob - split_posterior_probs[[k-1]]$pos_prob
ddK <- split_posterior_probs[[k+1]]$pos_prob-2*split_posterior_probs[[k]]$pos_prob+split_posterior_probs[[k-1]]$pos_prob
if ( isTRUE(sd(LK) == 0 ) )stop("No deviation between runs of the same K. Evanno statistics cannot be computed.")
} else {
dK <- rep(NA, length(LK))
ddK <- rep(NA, length(LK))
}
output_values[[k]] <-  data.frame(K = as.numeric(names(split_posterior_probs)[k]),
variable = output_variables,
value = c(mean(LK), mean(dK), mean(abs(ddK)), mean(abs(ddK))/sd(LK)),
sd = c(sd(LK), sd(dK), sd(ddK), NA))
}
posterior_probs_summary <- rbindlist(output_values)
if (plot) {
gg <- ggplot(posterior_probs_summary, aes_(x=~K, y=~value)) +
geom_point() +
facet_wrap(~variable, ncol=2, scales = "free_y") +
geom_errorbar(aes_q(ymax=quote(value+sd), ymin=quote(value-sd))) +
theme_bw() +
scale_x_continuous(breaks = min(posterior_probs_summary$K):max(posterior_probs_summary$K))
suppressWarnings(print(gg))
}
return(posterior_probs_summary)
}
#' @importFrom stats sd
bestK_structure <- function(posterior_probs, plot) {
# look for change point in log likelihood plot
# summarise data by K
posterior_probs_byK <- split(posterior_probs, posterior_probs$K)
posterior_probs_summary <- rbindlist(lapply(posterior_probs_byK,
function(i) data.frame(K = unique(i$K),
variable = c('L(K)', 'AIC', 'BIC', 'DIC'),
value = c(mean(i$pos_prob), mean(i$aic), mean(i$bic), mean(i$dic)),
sd = c(sd(i$pos_prob), sd(i$aic), sd(i$bic), sd(i$dic)))))
#generate plot
if (plot) {
gg <- ggplot(posterior_probs_summary, aes_(x=~K, y=~value)) +
geom_point() +
geom_errorbar(aes_q(ymax=quote(value+sd),
ymin=quote(value-sd)), width=0.1) +
theme_bw() +
facet_wrap(~variable, ncol=2, scales = "free_y") +
scale_x_continuous(breaks = min(posterior_probs_summary$K):max(posterior_probs_summary$K)) +
ylab("Mean log posterior probability")
suppressWarnings(print(gg))
}
return(posterior_probs_summary)
}
is.sequential <- function(x){
x <- as.numeric(x)
all(diff(x) == diff(x)[1])
}
install.packages("C:/Users/eschumacher/Downloads/starmie_0.1.2.tar.gz", repos = NULL, type = "source")
