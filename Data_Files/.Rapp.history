a<-c(10,12,14,16)
b<-c(10,12,14)
a%in%b
25!
?factorial
factorial(4)
factorial(25)/(factorial(10)*factorial(15))
factorial(25)/(factorial(10)*factorial(15))*.5^25*.5^15
factorial(25)/(factorial(12)*factorial(13))*.5^25*.5^13
factorial(25)/(factorial(12)*factorial(13))*.5^12*.5^13
binom(250,.5)
?pbinom
dbinom(250,.5)
?dbinom
rbinom(12,25,.5)
rbinom(250,25,.5)
hist(rbinom(250,25,.5))
hist(rbinom(250,25,.56))
par(mfrow=c(2,1))
hist(rbinom(250,25,.56))
hist(rbinom(250,25,.5))
hist(rbinom(250,25,.56),xlim=c(0,25))
hist(rbinom(250,25,.5),xlim=c(0,25))
hist(rbinom(25,25,.5),xlim=c(0,25))
hist(rbinom(25,25,.56),xlim=c(0,25))
900/16500
32/8260
30/1390
5000/3
5000*.3
1/9
23/.36
64*.36
64*.3
63*.3
6/.35
8/.47
30/1390
32/8260
257/60000
200/37.5
250/37.5
68+97+100+40
/4
305/4
2/3 +1/9
.7777777/2
39.51+52.28
36.23+7.22+42.09+192.60+5.08
47.42+34.72
63.02+19.72+59.17+46.14+16.59+63.96
11.47+39.53
95000/52
95000/52*2
45000/52*2
245 + 114+114
532 +267+ 274
155+134+284
129+143+255
2.5*100
/35
250/35
310/35
310/35/8
45000/52
/37.5
45000/52/37.5
23*535
12300*.27
14200/535
.999^10
.999^100
.999^30
.9995^100
.999^8
1381+568
1381+568+3183*.8
1381+568+3183*.9
1381+568+3183*.85
1381+568+3183*.88
2000/35
24.15*.1.05
24.15*1.05
17.53*1.05
45*1.28
45*1.28*1.5
37.5*25*1.3
37.5*25*1.3*3
3178/3
1381/2
1381/2+ 1059
1381/2+ 1059+1059
762/141
762/174
log(50)
407+2428+206+1170
250*5
250*5/60
10000*5000
10000*50
350/130000
52*37.5*50
52*37.5*40
2500/40
3000/40
1000/40
24000*.07
60*2*50
60*2*40
40*37.5*52
60*70
*50
60_70
13*40
20*20*17
1923*6
1923*6*1.28
1923*6*.25
4580/80
*36
4580/80*36
27/3.8
3.8*52
3.8*26
9/15
20/135
360/.56
137/.21
20.51*37.5*52
1300*2+2210+2050
-9185
1300*2+2210+2050-9185
2325+2300
17500-4625
2300+2300+1000+2300+4000
-17500
2300+2300+1000+2300+4000-17500
80/150
12.92+8.33
setwd("/Users/shoban/git/IMLS_GCC_QUAC_ZAIN/")
ls()
source("../Analyses/Functions/Fa_sample_funcs.R")#
#
#These numbers designate the populations for wild and garden, for Quercus and Zamia#
#Used in code below to subset the genpop objects by wild and garden#
#The ZAIN has some wild populations excluded- NOTE come back to this to discuss#
garden_pop_numbers<-list(1:17,1:10)#
wild_pop_numbers<-list(18:21,c(11:19, 23:26, 28:32, 34:35))
source("/Analyses/Functions/Fa_sample_funcs.R")#
#
#These numbers designate the populations for wild and garden, for Quercus and Zamia#
#Used in code below to subset the genpop objects by wild and garden#
#The ZAIN has some wild populations excluded- NOTE come back to this to discuss#
garden_pop_numbers<-list(1:17,1:10)#
wild_pop_numbers<-list(18:21,c(11:19, 23:26, 28:32, 34:35))
source("Analyses/Functions/Fa_sample_funcs.R")#
#
#These numbers designate the populations for wild and garden, for Quercus and Zamia#
#Used in code below to subset the genpop objects by wild and garden#
#The ZAIN has some wild populations excluded- NOTE come back to this to discuss#
garden_pop_numbers<-list(1:17,1:10)#
wild_pop_numbers<-list(18:21,c(11:19, 23:26, 28:32, 34:35))
sp<-1
for (sp in 1:2){#
 	#Right now just doing the first two files#
	 gen_inp_filenames<-c("Adegenet_Files/QUAC_woK_allpop_clean.gen", "Adegenet_Files/ZAIN_rebinned_allpop_clean.gen", "Adegenet_Files/ZAIN_rebinned_sample_clean.gen")#
	 outp_filenames<-c("QUAC_woK_indiv_rep_percents", "ZAIN_indiv_rep_percents", "ZAIN_red_indiv_rep_percents")#
	sp_genind <- read.genepop(gen_inp_filenames[sp], ncode = 3)#
	#allele categories list#
	all_cat_list <-c("global","glob_v_com","glob_com","glob_lowfr","glob_rare")#
	#vector of duplicate reps (for 1 to 10 individuals)#
	 dup_reps <- c(0:9)#
	#create garden genind. #
	#Note this cannot be done with seppop, because seppop will count only alleles in your subset, thus possibly "losing" wild alleles#
	num_garden_ind<-sum(table(sp_genind@pop)[garden_pop_numbers[[sp]]])#
	sp_garden_genind <- sp_genind[1:num_garden_ind,]#
	#rename pops#
	levels(sp_garden_genind@pop) <- rep("Garden",length(garden_pop_numbers[[sp]]))#
	#create wild genind object #
	#NOTE- This is actually quite tricky because unlike garden populations, wild populations kept are scattered through the dataset for ZAIN#
	#So we have to create two vectors- a vector of "starting individuals" and "ending individuals"#
	#and use those vectors to populate a list which will go from starting to ending individual of each population, all glued together#
	#then you have to unlist this list to make a vector#
	wild_ind_list<-list()#
	for (i in wild_pop_numbers[[sp]]){#
		wild_ind_list[[i]]<-(cumsum(table(sp_genind@pop))-table(sp_genind@pop)+1)[i]:cumsum(table(sp_genind@pop))[i]#
	}#
	sp_wild_genind <- sp_genind[unlist(wild_ind_list),]#
	#rename pops #
	levels(sp_wild_genind@pop) <- rep("Wild",length(wild_pop_numbers[[sp]]))#
	num_wild_ind <- as.numeric(table(sp_wild_genind@pop))#
	#convert to the wild genpop object#
	sp_wild_genpop <- genind2genpop(sp_wild_genind)#
	#calculate the allele categories in the wild populations#
	sp_all_cat <- get.allele.cat(sp_wild_genpop, 1, 1, num_wild_ind, n_drop = 0, glob_only = TRUE)	#
	#subset to allele of interest e.g. exlcuding regional alleles #
	sp_all_cat <- sp_all_cat[1:5]#
	##################################
	#	How many individuals have each allele#
	##################################
	#create a list to store the number of individuals representing each allele #
	#This list is length of 5, the five allele categories we are concerned with#
	#the elements of the list are vectors... the vector is length equal to the number of alleles in each category#
	# each element of the vector will be the number of individuals having that allele#
	#for example, [[1]][1:3] might be 5,1, 10 which means five individuals, 0 individuals, and 10 individuals have those first three alleles, resepectively#
	num_indiv_rep_list <- list(vector(), vector(), vector(), vector(), vector())#
	num_indiv_rep_list_he <-  list(vector(), vector(), vector(), vector(), vector())#
	num_indiv_rep_list_ho <-  list(vector(), vector(), vector(), vector(), vector())#
	#This for loop goes through the 5 allele categories of interest#
	#It then goes through all the alleles in a category#
	#It then counts the number of individuals, the number of homozygotes, and the number of heterozygotes for that allele#
	#recall that sp_garden_genind@tab is a matrix of nrows= number of individuals and ncols = number of alleles#
	#so every cell of the matrix is an individual-allele combination, and the data in the cell are the number of copies of that allele in that individual#
	#An individual can have the allele in 2 copies (homozygote), 1 copy (heterozygote), or not have the allele (0)#
	for(cat in 1:length(sp_all_cat)){#
	  num_alleles_in_cat <- length(sp_all_cat[[cat]])#
	  for (a in 1:num_alleles_in_cat){#
	    num_indiv_rep_list[[cat]][a] <- sum(sp_garden_genind@tab[,sp_all_cat[[cat]]][,a] > 0, na.rm=T)	#either he or ho#
	    num_indiv_rep_list_he[[cat]][a] <- sum(sp_garden_genind@tab[,sp_all_cat[[cat]]][,a] == 1, na.rm=T) 	#he#
	    num_indiv_rep_list_ho[[cat]][a] <- sum(sp_garden_genind@tab[,sp_all_cat[[cat]]][,a] == 2, na.rm=T)	#ho#
	  }#
	}#
	#############################################################
	# Percent of alleles represented in greater than "dup" number of individuals#
	#############################################################
	#create data frame to save results  #
	#In this case the results are the percent of alleles present in greater than "dup" number of individuals#
	#The he and ho stand for individuals in the heterozygous and homozygous states#
	percent_indiv_results <- matrix(nrow = length(dup_reps),#
	                      ncol = length(sp_all_cat))#
	percent_indiv_results_he <- matrix(nrow = length(dup_reps),#
	                         ncol = length(sp_all_cat))#
	percent_indiv_results_ho <- matrix(nrow = length(dup_reps),#
	                         ncol = length(sp_all_cat))#
	#This loop goes through the number of "dups" from 1 to 10 (with 1 meaning no "backup")#
	#Then through the loop of allele categories (5)#
	#Within that loop it determines if the number of individuals with that allele is greater than "dup", #
	#then divides the number of alleles meeting that criteria by the total number of alleles #
	#thus returning the proportion of alleles contained in more than "dup" individuals#
	#The he and ho stand for individuals in the heterozygous and homozygous states#
	for(dup in dup_reps){#
	  for(cat in 1:length(sp_all_cat)){#
	    #create data frame to store results #
	    percent_indiv_results[dup+1,cat] <- sum(num_indiv_rep_list[[cat]]>dup)/length(sp_all_cat[[cat]])#
	    percent_indiv_results_he[dup+1,cat] <- sum(num_indiv_rep_list_he[[cat]]>dup)/length(sp_all_cat[[cat]])#
	    percent_indiv_results_ho[dup+1,cat] <- sum(num_indiv_rep_list_ho[[cat]]>dup)/length(sp_all_cat[[cat]])#
	  }#
	}
gen_inp_filenames<-c("Adegenet_Files/QUAC_woK_allpop_clean.gen", "Adegenet_Files/ZAIN_rebinned_allpop_clean.gen", "Adegenet_Files/ZAIN_rebinned_sample_clean.gen")#
	 outp_filenames<-c("QUAC_woK_indiv_rep_percents", "ZAIN_indiv_rep_percents", "ZAIN_red_indiv_rep_percents")#
	sp_genind <- read.genepop(gen_inp_filenames[sp], ncode = 3)#
	#allele categories list#
	all_cat_list <-c("global","glob_v_com","glob_com","glob_lowfr","glob_rare")#
	#vector of duplicate reps (for 1 to 10 individuals)#
	 dup_reps <- c(0:9)#
	#create garden genind. #
	#Note this cannot be done with seppop, because seppop will count only alleles in your subset, thus possibly "losing" wild alleles#
	num_garden_ind<-sum(table(sp_genind@pop)[garden_pop_numbers[[sp]]])#
	sp_garden_genind <- sp_genind[1:num_garden_ind,]#
	#rename pops#
	levels(sp_garden_genind@pop) <- rep("Garden",length(garden_pop_numbers[[sp]]))#
	#create wild genind object #
	#NOTE- This is actually quite tricky because unlike garden populations, wild populations kept are scattered through the dataset for ZAIN#
	#So we have to create two vectors- a vector of "starting individuals" and "ending individuals"#
	#and use those vectors to populate a list which will go from starting to ending individual of each population, all glued together#
	#then you have to unlist this list to make a vector#
	wild_ind_list<-list()#
	for (i in wild_pop_numbers[[sp]]){#
		wild_ind_list[[i]]<-(cumsum(table(sp_genind@pop))-table(sp_genind@pop)+1)[i]:cumsum(table(sp_genind@pop))[i]#
	}#
	sp_wild_genind <- sp_genind[unlist(wild_ind_list),]#
	#rename pops #
	levels(sp_wild_genind@pop) <- rep("Wild",length(wild_pop_numbers[[sp]]))#
	num_wild_ind <- as.numeric(table(sp_wild_genind@pop))#
	#convert to the wild genpop object#
	sp_wild_genpop <- genind2genpop(sp_wild_genind)#
	#calculate the allele categories in the wild populations#
	sp_all_cat <- get.allele.cat(sp_wild_genpop, 1, 1, num_wild_ind, n_drop = 0, glob_only = TRUE)	#
	#subset to allele of interest e.g. exlcuding regional alleles #
	sp_all_cat <- sp_all_cat[1:5]#
	##################################
	#	How many individuals have each allele#
	##################################
	#create a list to store the number of individuals representing each allele #
	#This list is length of 5, the five allele categories we are concerned with#
	#the elements of the list are vectors... the vector is length equal to the number of alleles in each category#
	# each element of the vector will be the number of individuals having that allele#
	#for example, [[1]][1:3] might be 5,1, 10 which means five individuals, 0 individuals, and 10 individuals have those first three alleles, resepectively#
	num_indiv_rep_list <- list(vector(), vector(), vector(), vector(), vector())#
	num_indiv_rep_list_he <-  list(vector(), vector(), vector(), vector(), vector())#
	num_indiv_rep_list_ho <-  list(vector(), vector(), vector(), vector(), vector())#
	#This for loop goes through the 5 allele categories of interest#
	#It then goes through all the alleles in a category#
	#It then counts the number of individuals, the number of homozygotes, and the number of heterozygotes for that allele#
	#recall that sp_garden_genind@tab is a matrix of nrows= number of individuals and ncols = number of alleles#
	#so every cell of the matrix is an individual-allele combination, and the data in the cell are the number of copies of that allele in that individual#
	#An individual can have the allele in 2 copies (homozygote), 1 copy (heterozygote), or not have the allele (0)#
	for(cat in 1:length(sp_all_cat)){#
	  num_alleles_in_cat <- length(sp_all_cat[[cat]])#
	  for (a in 1:num_alleles_in_cat){#
	    num_indiv_rep_list[[cat]][a] <- sum(sp_garden_genind@tab[,sp_all_cat[[cat]]][,a] > 0, na.rm=T)	#either he or ho#
	    num_indiv_rep_list_he[[cat]][a] <- sum(sp_garden_genind@tab[,sp_all_cat[[cat]]][,a] == 1, na.rm=T) 	#he#
	    num_indiv_rep_list_ho[[cat]][a] <- sum(sp_garden_genind@tab[,sp_all_cat[[cat]]][,a] == 2, na.rm=T)	#ho#
	  }#
	}#
	#############################################################
	# Percent of alleles represented in greater than "dup" number of individuals#
	#############################################################
	#create data frame to save results  #
	#In this case the results are the percent of alleles present in greater than "dup" number of individuals#
	#The he and ho stand for individuals in the heterozygous and homozygous states#
	percent_indiv_results <- matrix(nrow = length(dup_reps),#
	                      ncol = length(sp_all_cat))#
	percent_indiv_results_he <- matrix(nrow = length(dup_reps),#
	                         ncol = length(sp_all_cat))#
	percent_indiv_results_ho <- matrix(nrow = length(dup_reps),#
	                         ncol = length(sp_all_cat))#
	#This loop goes through the number of "dups" from 1 to 10 (with 1 meaning no "backup")#
	#Then through the loop of allele categories (5)#
	#Within that loop it determines if the number of individuals with that allele is greater than "dup", #
	#then divides the number of alleles meeting that criteria by the total number of alleles #
	#thus returning the proportion of alleles contained in more than "dup" individuals#
	#The he and ho stand for individuals in the heterozygous and homozygous states#
	for(dup in dup_reps){#
	  for(cat in 1:length(sp_all_cat)){#
	    #create data frame to store results #
	    percent_indiv_results[dup+1,cat] <- sum(num_indiv_rep_list[[cat]]>dup)/length(sp_all_cat[[cat]])#
	    percent_indiv_results_he[dup+1,cat] <- sum(num_indiv_rep_list_he[[cat]]>dup)/length(sp_all_cat[[cat]])#
	    percent_indiv_results_ho[dup+1,cat] <- sum(num_indiv_rep_list_ho[[cat]]>dup)/length(sp_all_cat[[cat]])#
	  }#
	}
library(adegenet)
gen_inp_filenames<-c("Adegenet_Files/QUAC_woK_allpop_clean.gen", "Adegenet_Files/ZAIN_rebinned_allpop_clean.gen", "Adegenet_Files/ZAIN_rebinned_sample_clean.gen")#
	 outp_filenames<-c("QUAC_woK_indiv_rep_percents", "ZAIN_indiv_rep_percents", "ZAIN_red_indiv_rep_percents")#
	sp_genind <- read.genepop(gen_inp_filenames[sp], ncode = 3)#
	#allele categories list#
	all_cat_list <-c("global","glob_v_com","glob_com","glob_lowfr","glob_rare")#
	#vector of duplicate reps (for 1 to 10 individuals)#
	 dup_reps <- c(0:9)
getwd()
setwd("/Users/shoban/git/IMLS_GCC_QUAC_ZAIN/Data_Files/")
gen_inp_filenames<-c("Adegenet_Files/QUAC_woK_allpop_clean.gen", "Adegenet_Files/ZAIN_rebinned_allpop_clean.gen", "Adegenet_Files/ZAIN_rebinned_sample_clean.gen")#
	 outp_filenames<-c("QUAC_woK_indiv_rep_percents", "ZAIN_indiv_rep_percents", "ZAIN_red_indiv_rep_percents")#
	sp_genind <- read.genepop(gen_inp_filenames[sp], ncode = 3)#
	#allele categories list#
	all_cat_list <-c("global","glob_v_com","glob_com","glob_lowfr","glob_rare")#
	#vector of duplicate reps (for 1 to 10 individuals)#
	 dup_reps <- c(0:9)
#create garden genind. #
	#Note this cannot be done with seppop, because seppop will count only alleles in your subset, thus possibly "losing" wild alleles#
	num_garden_ind<-sum(table(sp_genind@pop)[garden_pop_numbers[[sp]]])#
	sp_garden_genind <- sp_genind[1:num_garden_ind,]#
	#rename pops#
	levels(sp_garden_genind@pop) <- rep("Garden",length(garden_pop_numbers[[sp]]))#
	#create wild genind object #
	#NOTE- This is actually quite tricky because unlike garden populations, wild populations kept are scattered through the dataset for ZAIN#
	#So we have to create two vectors- a vector of "starting individuals" and "ending individuals"#
	#and use those vectors to populate a list which will go from starting to ending individual of each population, all glued together#
	#then you have to unlist this list to make a vector#
	wild_ind_list<-list()#
	for (i in wild_pop_numbers[[sp]]){#
		wild_ind_list[[i]]<-(cumsum(table(sp_genind@pop))-table(sp_genind@pop)+1)[i]:cumsum(table(sp_genind@pop))[i]#
	}#
	sp_wild_genind <- sp_genind[unlist(wild_ind_list),]#
	#rename pops #
	levels(sp_wild_genind@pop) <- rep("Wild",length(wild_pop_numbers[[sp]]))#
	num_wild_ind <- as.numeric(table(sp_wild_genind@pop))#
	#convert to the wild genpop object#
	sp_wild_genpop <- genind2genpop(sp_wild_genind)#
	#calculate the allele categories in the wild populations#
	sp_all_cat <- get.allele.cat(sp_wild_genpop, 1, 1, num_wild_ind, n_drop = 0, glob_only = TRUE)	#
	#subset to allele of interest e.g. exlcuding regional alleles #
	sp_all_cat <- sp_all_cat[1:5]#
	##################################
	#	How many individuals have each allele#
	##################################
	#create a list to store the number of individuals representing each allele #
	#This list is length of 5, the five allele categories we are concerned with#
	#the elements of the list are vectors... the vector is length equal to the number of alleles in each category#
	# each element of the vector will be the number of individuals having that allele#
	#for example, [[1]][1:3] might be 5,1, 10 which means five individuals, 0 individuals, and 10 individuals have those first three alleles, resepectively#
	num_indiv_rep_list <- list(vector(), vector(), vector(), vector(), vector())#
	num_indiv_rep_list_he <-  list(vector(), vector(), vector(), vector(), vector())#
	num_indiv_rep_list_ho <-  list(vector(), vector(), vector(), vector(), vector())#
	#This for loop goes through the 5 allele categories of interest#
	#It then goes through all the alleles in a category#
	#It then counts the number of individuals, the number of homozygotes, and the number of heterozygotes for that allele#
	#recall that sp_garden_genind@tab is a matrix of nrows= number of individuals and ncols = number of alleles#
	#so every cell of the matrix is an individual-allele combination, and the data in the cell are the number of copies of that allele in that individual#
	#An individual can have the allele in 2 copies (homozygote), 1 copy (heterozygote), or not have the allele (0)#
	for(cat in 1:length(sp_all_cat)){#
	  num_alleles_in_cat <- length(sp_all_cat[[cat]])#
	  for (a in 1:num_alleles_in_cat){#
	    num_indiv_rep_list[[cat]][a] <- sum(sp_garden_genind@tab[,sp_all_cat[[cat]]][,a] > 0, na.rm=T)	#either he or ho#
	    num_indiv_rep_list_he[[cat]][a] <- sum(sp_garden_genind@tab[,sp_all_cat[[cat]]][,a] == 1, na.rm=T) 	#he#
	    num_indiv_rep_list_ho[[cat]][a] <- sum(sp_garden_genind@tab[,sp_all_cat[[cat]]][,a] == 2, na.rm=T)	#ho#
	  }#
	}#
	#############################################################
	# Percent of alleles represented in greater than "dup" number of individuals#
	#############################################################
	#create data frame to save results  #
	#In this case the results are the percent of alleles present in greater than "dup" number of individuals#
	#The he and ho stand for individuals in the heterozygous and homozygous states#
	percent_indiv_results <- matrix(nrow = length(dup_reps),#
	                      ncol = length(sp_all_cat))#
	percent_indiv_results_he <- matrix(nrow = length(dup_reps),#
	                         ncol = length(sp_all_cat))#
	percent_indiv_results_ho <- matrix(nrow = length(dup_reps),#
	                         ncol = length(sp_all_cat))#
	#This loop goes through the number of "dups" from 1 to 10 (with 1 meaning no "backup")#
	#Then through the loop of allele categories (5)#
	#Within that loop it determines if the number of individuals with that allele is greater than "dup", #
	#then divides the number of alleles meeting that criteria by the total number of alleles #
	#thus returning the proportion of alleles contained in more than "dup" individuals#
	#The he and ho stand for individuals in the heterozygous and homozygous states#
	for(dup in dup_reps){#
	  for(cat in 1:length(sp_all_cat)){#
	    #create data frame to store results #
	    percent_indiv_results[dup+1,cat] <- sum(num_indiv_rep_list[[cat]]>dup)/length(sp_all_cat[[cat]])#
	    percent_indiv_results_he[dup+1,cat] <- sum(num_indiv_rep_list_he[[cat]]>dup)/length(sp_all_cat[[cat]])#
	    percent_indiv_results_ho[dup+1,cat] <- sum(num_indiv_rep_list_ho[[cat]]>dup)/length(sp_all_cat[[cat]])#
	  }#
	}
percent_indiv_results
sp_allele_cat
num_alleles_in_cat
sp_all_cat
sp_wild_cap_df <- matrix(nrow = (length(dup_reps)), ncol =5)
sp_wild_genpop
sp_alleles_cap <- colSums(seppop(sp_garden_genind),na.rm=T)
sp_alleles_cap <- colSums(seppop(sp_garden_genind@tab),na.rm=T)
sp_alleles_cap <- colSums(sp_garden_genind@tab),na.rm=T)
sp_alleles_cap <- colSums(sp_garden_genind@tab,na.rm=T)
sp_alleles_cap
num_indiv_rep_list
num_indiv_rep_list[[1]]
sp_alleles_cap-num_indiv_rep_list[[1]]
length(num_indiv_rep_list)
length(num_indiv_rep_list[[1]])
length(sp_alleles_cat)
length(sp_alleles_cap)
gen_inp_filenames<-c("Adegenet_Files/QUAC_woK_allpop_clean.gen", "Adegenet_Files/ZAIN_rebinned_allpop_clean.gen", "Adegenet_Files/ZAIN_rebinned_sample_clean.gen")#
	 outp_filenames<-c("QUAC_woK_indiv_rep_percents", "ZAIN_indiv_rep_percents", "ZAIN_red_indiv_rep_percents")#
	sp_genind <- read.genepop(gen_inp_filenames[sp], ncode = 3)#
	#allele categories list#
	all_cat_list <-c("global","glob_v_com","glob_com","glob_lowfr","glob_rare")#
	#vector of duplicate reps (for 1 to 10 individuals)#
	 dup_reps <- c(0:9)#
	#create garden genind. #
	#Note this cannot be done with seppop, because seppop will count only alleles in your subset, thus possibly "losing" wild alleles#
	num_garden_ind<-sum(table(sp_genind@pop)[garden_pop_numbers[[sp]]])#
	sp_garden_genind <- sp_genind[1:num_garden_ind,]#
	#rename pops#
	levels(sp_garden_genind@pop) <- rep("Garden",length(garden_pop_numbers[[sp]]))#
	#create wild genind object #
	#NOTE- This is actually quite tricky because unlike garden populations, wild populations kept are scattered through the dataset for ZAIN#
	#So we have to create two vectors- a vector of "starting individuals" and "ending individuals"#
	#and use those vectors to populate a list which will go from starting to ending individual of each population, all glued together#
	#then you have to unlist this list to make a vector#
	wild_ind_list<-list()#
	for (i in wild_pop_numbers[[sp]]){#
		wild_ind_list[[i]]<-(cumsum(table(sp_genind@pop))-table(sp_genind@pop)+1)[i]:cumsum(table(sp_genind@pop))[i]#
	}#
	sp_wild_genind <- sp_genind[unlist(wild_ind_list),]#
	#rename pops #
	levels(sp_wild_genind@pop) <- rep("Wild",length(wild_pop_numbers[[sp]]))#
	num_wild_ind <- as.numeric(table(sp_wild_genind@pop))#
	#convert to the wild genpop object#
	sp_wild_genpop <- genind2genpop(sp_wild_genind)#
	#calculate the allele categories in the wild populations#
	sp_all_cat <- get.allele.cat(sp_wild_genpop, 1, 1, num_wild_ind, n_drop = 0, glob_only = TRUE)	#
	#subset to allele of interest e.g. exlcuding regional alleles #
	sp_all_cat <- sp_all_cat[1:5]
sp_all_cat
sp_allele_cat
sp_allele_cat <- get.allele.cat(sp_wild_genpop, 1, 1, num_wild_ind, n_drop = ndrop, glob_only = TRUE)
sp_allele_cat <- get.allele.cat(sp_wild_genpop, 1, 1, num_wild_ind, n_drop = 0, glob_only = TRUE)
sp_allele_cat
sp_alleles_cap[sp_allele_cat[[cat]]
]
cat<-1
sp_alleles_cap[sp_allele_cat[[cat]]]
length(sp_alleles_cap[sp_allele_cat[[cat]]])
sp_alleles_cap[sp_allele_cat[[1]]]-num_indiv_rep_list[[1]]
for(cat in 1:length(list_allele_cat)){#
      for(dup in 1:length(dup_reps)){#
      #calculating alleles that exist by allelic category#
      sp_all_exist_df[dup, cat] <- sum(sp_wild_genpop@tab[sp_allele_cat[[cat]]] > dup_reps[[dup]])#
      #now determine how many wild alleles were captured per category #
      sp_wild_cap_df[dup, cat] <- (sum(sp_alleles_cap[sp_allele_cat[[cat]]] > dup_reps[[dup]])/length(sp_allele_cat[[cat]]))#
      #code to store as one data frame #
      sp_allele_cap[dup, cat] <- paste0(signif((sp_wild_cap_df[dup,cat]*100),3), "%")#
      ##try to add the individual rep #
      #save alleles existing#
      num_alleles_in_cat <- length(sp_allele_cat[[cat]])#
      #save each category#
      #for(a in 1:num_alleles_in_cat){#
      #    num_rep_list[[cat]][a] <- sum(sp_garden_genind@tab[,sp_allele_cat[[cat]]][,a] > 0, na.rm=T)#
      #}#
      #save data frame with #
      #sp_ind_rep_df[dup,cat] <- sum(num_rep_list[[cat]]>dup_reps[[dup]], na.rm = TRUE)/length(num_rep_list[[cat]])#
      }#
    }
for(cat in 1:5){#
      for(dup in 1:length(dup_reps)){#
      #calculating alleles that exist by allelic category#
      sp_all_exist_df[dup, cat] <- sum(sp_wild_genpop@tab[sp_allele_cat[[cat]]] > dup_reps[[dup]])#
      #now determine how many wild alleles were captured per category #
      sp_wild_cap_df[dup, cat] <- (sum(sp_alleles_cap[sp_allele_cat[[cat]]] > dup_reps[[dup]])/length(sp_allele_cat[[cat]]))#
      #code to store as one data frame #
      sp_allele_cap[dup, cat] <- paste0(signif((sp_wild_cap_df[dup,cat]*100),3), "%")#
      ##try to add the individual rep #
      #save alleles existing#
      num_alleles_in_cat <- length(sp_allele_cat[[cat]])#
      #save each category#
      #for(a in 1:num_alleles_in_cat){#
      #    num_rep_list[[cat]][a] <- sum(sp_garden_genind@tab[,sp_allele_cat[[cat]]][,a] > 0, na.rm=T)#
      #}#
      #save data frame with #
      #sp_ind_rep_df[dup,cat] <- sum(num_rep_list[[cat]]>dup_reps[[dup]], na.rm = TRUE)/length(num_rep_list[[cat]])#
      }#
    }
for(dup in 1:length(dup_reps)){#
      #calculating alleles that exist by allelic category#
      sp_all_exist_df[dup, cat] <- sum(sp_wild_genpop@tab[sp_allele_cat[[cat]]] > dup_reps[[dup]])#
      #now determine how many wild alleles were captured per category #
      sp_wild_cap_df[dup, cat] <- (sum(sp_alleles_cap[sp_allele_cat[[cat]]] > dup_reps[[dup]])/length(sp_allele_cat[[cat]]))#
      #code to store as one data frame #
      sp_allele_cap[dup, cat] <- paste0(signif((sp_wild_cap_df[dup,cat]*100),3), "%")#
      ##try to add the individual rep #
      #save alleles existing#
      num_alleles_in_cat <- length(sp_allele_cat[[cat]])#
      #save each category#
      #for(a in 1:num_alleles_in_cat){#
      #    num_rep_list[[cat]][a] <- sum(sp_garden_genind@tab[,sp_allele_cat[[cat]]][,a] > 0, na.rm=T)#
      #}#
      #save data frame with #
      #sp_ind_rep_df[dup,cat] <- sum(num_rep_list[[cat]]>dup_reps[[dup]], na.rm = TRUE)/length(num_rep_list[[cat]])#
      }
sp_all_exist_df[dup, cat] <- sum(sp_wild_genpop@tab[sp_allele_cat[[cat]]] > dup_reps[[dup]])
sp_all_exist_df <- matrix(nrow = (length(dup_reps)), ncol = length(list_allele_cat))
sp_all_exist_df <- matrix(nrow = (length(dup_reps)), ncol = length(list_allele_cat))
sp_all_exist_df <- matrix(nrow = (length(dup_reps)), ncol = length(list_allele_cat))
sp_all_exist_df <- matrix(nrow = (length(dup_reps)), ncol = 5)
for(cat in 1:5){#
      for(dup in 1:length(dup_reps)){#
      #calculating alleles that exist by allelic category#
      sp_all_exist_df[dup, cat] <- sum(sp_wild_genpop@tab[sp_allele_cat[[cat]]] > dup_reps[[dup]])#
      #now determine how many wild alleles were captured per category #
      sp_wild_cap_df[dup, cat] <- (sum(sp_alleles_cap[sp_allele_cat[[cat]]] > dup_reps[[dup]])/length(sp_allele_cat[[cat]]))#
      #code to store as one data frame #
      sp_allele_cap[dup, cat] <- paste0(signif((sp_wild_cap_df[dup,cat]*100),3), "%")#
      ##try to add the individual rep #
      #save alleles existing#
      num_alleles_in_cat <- length(sp_allele_cat[[cat]])#
      #save each category#
      #for(a in 1:num_alleles_in_cat){#
      #    num_rep_list[[cat]][a] <- sum(sp_garden_genind@tab[,sp_allele_cat[[cat]]][,a] > 0, na.rm=T)#
      #}#
      #save data frame with #
      #sp_ind_rep_df[dup,cat] <- sum(num_rep_list[[cat]]>dup_reps[[dup]], na.rm = TRUE)/length(num_rep_list[[cat]])#
      }#
    }
sp_alleles_cap <- colSums(sp_garden_wild_genind@tab,na.rm=T)
sp_alleles_cap <- colSums(sp_garden_genind@tab,na.rm=T)
for(cat in 1:5){#
      for(dup in 1:length(dup_reps)){#
      #calculating alleles that exist by allelic category#
      sp_all_exist_df[dup, cat] <- sum(sp_wild_genpop@tab[sp_allele_cat[[cat]]] > dup_reps[[dup]])#
      #now determine how many wild alleles were captured per category #
      sp_wild_cap_df[dup, cat] <- (sum(sp_alleles_cap[sp_allele_cat[[cat]]] > dup_reps[[dup]])/length(sp_allele_cat[[cat]]))#
      #code to store as one data frame #
      sp_allele_cap[dup, cat] <- paste0(signif((sp_wild_cap_df[dup,cat]*100),3), "%")#
      ##try to add the individual rep #
      #save alleles existing#
      num_alleles_in_cat <- length(sp_allele_cat[[cat]])#
      #save each category#
      #for(a in 1:num_alleles_in_cat){#
      #    num_rep_list[[cat]][a] <- sum(sp_garden_genind@tab[,sp_allele_cat[[cat]]][,a] > 0, na.rm=T)#
      #}#
      #save data frame with #
      #sp_ind_rep_df[dup,cat] <- sum(num_rep_list[[cat]]>dup_reps[[dup]], na.rm = TRUE)/length(num_rep_list[[cat]])#
      }#
    }
for(cat in 1:5){#
      for(dup in 1:length(dup_reps)){#
      #calculating alleles that exist by allelic category#
      sp_all_exist_df[dup, cat] <- sum(sp_wild_genpop@tab[sp_allele_cat[[cat]]] > dup_reps[[dup]])#
      #now determine how many wild alleles were captured per category #
      sp_wild_cap_df[dup, cat] <- (sum(sp_alleles_cap[sp_allele_cat[[cat]]] > dup_reps[[dup]])/length(sp_allele_cat[[cat]]))#
      #code to store as one data frame #
      #save data frame with #
      #sp_ind_rep_df[dup,cat] <- sum(num_rep_list[[cat]]>dup_reps[[dup]], na.rm = TRUE)/length(num_rep_list[[cat]])#
      }#
    }
sp_wild_cap_df
sp_wild_cap_df[,1:5]-num_indiv_rep_list[,1:5]
num_indiv_rep_list
sp_wild_cap_df[,1:5]-percent_indiv_results[,1:5]
sp_alleles_cap[sp_allele_cat[[1]]]-num_indiv_rep_list[[1]]
sp_wild_cap_df[,1:5]-percent_indiv_results[,1:5]
sp_alleles_cap[sp_allele_cat[[5]]]-num_indiv_rep_list[[5]]
sp_alleles_cap[sp_allele_cat[[3]]]-num_indiv_rep_list[[3]]
sp_alleles_cap[sp_allele_cat[[2]]]-num_indiv_rep_list[[2]]
6*20*16.5
37.5*52
60*1.5*1.3
60*2.5*1.3
2.25*60*1.28
59*1.28*2.25
17/23
18/23
18/24
